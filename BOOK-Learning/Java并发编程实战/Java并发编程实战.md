# JAVA并发编程实战

## 概述：
* 多线程优势：
    * 并发程序可以使复杂的异步代码变得更加简单（异步性指当任务划分为更细粒度时，在不影响本次任务的前提下，可同时进行其他任务），通过线程可以将复杂异步的工作流分解为一组简单且同步的工作流，每个工作流在一个单独的线程中运行，在特定位置同步；
    * 同时多线程可以充分利用处理器的计算资源（线程在共享进程资源的同时，拥有各自的PC，栈和局部变量，为计算机基本的调度单位，相同进程的多个线程可在不同CPU上运行）。
* 线程安全：当多个线程共享变量，需要操作相同的内存地址，可能由于无法预料的执行顺序发生错误,此时需要利用同步机制对涉及共享变量的操作加以协同（如i++并非线程安全（会出现竞争条件），它可以分解为三个操作：1读取，2加一，3写回）

* 其他：
    * 进程间通信机制：套接字，信号处理器，共享内存，信号量以及文件等；
    * 活跃性问题: 指程序永远不能结束，如串行程序中的无限循环，多线程中的死锁，饥饿，活锁等；
    * 处理不当多线程可能会影响程序性能，多线程调度可能导致频繁的上下文切换，同步机制等需要额外的性能开销，
* 线程无处不在，当我们调用一些多线程相关的模块框架时，在整个程序中应注意与之相关的线程安全问题，如：
    * Timer类:主要用于线程定时调度，管理线程的执行时间
    * Servlet/JSP:主要用来处理请求，通常会为一个请求分配一个单独的处理线程；
    * RMI远程方法调用: 必须将传递的参数打包(列集)，然后由远程JVM拆包(散集)，远程对象需要注意正确协同多个对象中的共享状态，以及对远程对象本身状态的访问；
    * Swing/AWT：GUI应用程序通常会为每个事件分配一个单独的事件处理器线程；


## 线程安全性：
* 编写线程安全的代码核心在于对状态访问操作进行管理（特别是对共享和可变状态的访问），当多个线程访问某个状态变量且涉及写入修改操作时，必须采用同步机制来协同这些线程对变量的访问，如java中的主要同步机制关键字synchronized(提供一种独占的加锁方式)，
  此外同步还包括volatile类型变量，显示锁以及原子变量。
* 通常将程序状态封装在一个类中，程序状态良好的封装性有助于实现程序的线程安全性；
* 线程安全类：当多个线程访问某个类时，这个类始终都能表现出正确的行为，则说这个类线程安全（核心为正确性，指某个类的行为与其规范完全一致，在良好的规范中通常会定义各种不变性条件和约束对象的状态，以及各种后验条件来约束对象操作的结果）。

* 原子性：
    * 竞态条件： 当某个计算的正确性取决于多个线程交替执行的时序，会发生竞态条件（结果具有偶然性），常见的竞态条件类型为先检查在执行，本质为可能基于一个失效的状态来做出判断或执行计算，为避免竞态条件错误结果的出现需要将一组复合操作
    变为原子操作(执行过程不可打断)

## 加锁机制：
* 多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。当不变性条件涉及多个变量时，某个变量的值会对其他变量产生约束，则为保证线程安全和状态一致性，当更新一个变量时，需要在同一个原子操作中对相关变量进行更新。
* 内置锁：
    * 同步代码块，包括作为锁的对象引用和由这个锁保护的同步代码块（如由关键字synchronized修饰的方法为一个横跨整个方法体的同步代码块，锁为方法调用所在的对象，静态的synchronized方法以class对象作为锁）
    * java中的每个对的每个对象都可以用作实现同步的锁，称为内置锁或监视器锁。线程在进入同步代码块时自动获得锁，在退出同步代码块时自动释放所。
    * 内置锁为互斥锁，保证每次只能由一个线程获得，当另一个线程想要获得被其他线程持有的锁时，必需阻塞等待，直到该锁被释放。因此内置锁可以保证同步代码块以原子方式执行
* 重入：
     * 内置锁可重入，意味着一个线程可以获得已由它本身持有的锁，获得锁的粒度是线程，而不是调用。
     * 实现方法，通常为每个锁关联一个获取计数值和所有者对象；
     * 重入提高加锁行为的封装性，如避免的当子类重写父类的synchronized方法，调用父类中的方法时出现死锁情况的发生
* 用锁保护状态：
    * 锁能保证代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问，确保状态的一致性 
    * 通常将所有可变状态封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得该对象上不会发生并发访问
    * 对于每个包含多个变量的不变性条件，其中涉及的所有变量都应该由一个锁来保护。
* 活跃性与性能：粗粒度加锁行为，可能影响程序的并发性，另外获得/释放锁同样需要一定的性能开销，粒度过细的加锁行为也会影响程序性能，在利用加锁来进行同步控制时，应注意程序简单性与并发性的平衡，提高程序性能。

## 对象共享：
* 可见性:当读/写操作不在一个线程中时，一个线程的写入的最新结果未必可以在另一个线程立即读到(读到的可能为过期的失效值)，为确保多个线程对内存写入操作的可见性，需要使用同步机制。
* 非原子的64位操作：JVM内存模型要求，对于读/写操作都必须是原子操作，但对于64位的非volatile变量读/写操作会被分解为两个32位的操作（因此对于一个64位的变量，如果读/写操作不在一个线程中，则可能出现读到的一个数值的高32位为写入前的失效值，低32位为写入后的最新值的情况） 
* 加锁与可见性：内置锁可以确保一个线程以可预测的方式来查看另一个线程的执行结果(对于同一个同步代码块，读线程线程在获得锁后，可以之前写线程对该同步代码块的所有操作结果)
* volatile变量：相比内置锁，一种更弱的同步机制，确保将变量的更细操作通知其他线程：
    * 对于valatile类型的变量，编译器或在运行时会注意到此变量共享，因此不会将该变量上的操作与其他内存操作一起重排序。同时volatile变量的值不会缓存在寄存器或其他处理器不可见的地方，因此在读取volatile类型变量的值时总会得到最新写入的值。(在操作volatile类型变量时不会执行加锁操作，因此不会出现线程阻塞，)
    * 不应过分依赖volatile实现同步机制，通常当volatileb能过简化代码的实现以及对同步策略的验证时使用，通常用作某个操作完成，发生中断或者状态的标记，如检查某个状态标记以判断是否退出循环。
* 发布与逸出：