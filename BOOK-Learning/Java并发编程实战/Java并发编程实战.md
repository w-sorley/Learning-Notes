
# JAVA并发编程实战
## 概述：
* 多线程优势：
    * 并发程序可以使复杂的异步代码变得更加简单（异步性指当任务划分为更细粒度时，在不影响本次任务的前提下，可同时进行其他任务），通过线程可以将复杂异步的工作流分解为一组简单且同步的工作流，每个工作流在一个单独的线程中运行，在特定位置同步；
    * 同时多线程可以充分利用处理器的计算资源（线程在共享进程资源的同时，拥有各自的PC，栈和局部变量，为计算机基本的调度单位，相同进程的多个线程可在不同CPU上运行）。
* 线程安全：当多个线程共享变量，需要操作相同的内存地址，可能由于无法预料的执行顺序发生错误,此时需要利用同步机制对涉及共享变量的操作加以协同（如i++并非线程安全（会出现竞争条件），它可以分解为三个操作：1读取，2加一，3写回）

* 其他：
    * 进程间通信机制：套接字，信号处理器，共享内存，信号量以及文件等；
    * 活跃性问题: 指程序永远不能结束，如串行程序中的无限循环，多线程中的死锁，饥饿，活锁等；
    * 处理不当多线程可能会影响程序性能，多线程调度可能导致频繁的上下文切换，同步机制等需要额外的性能开销，
* 线程无处不在，当我们调用一些多线程相关的模块框架时，在整个程序中应注意与之相关的线程安全问题，如：
    * Timer类:主要用于线程定时调度，管理线程的执行时间
    * Servlet/JSP:主要用来处理请求，通常会为一个请求分配一个单独的处理线程；
    * RMI远程方法调用: 必须将传递的参数打包(列集)，然后由远程JVM拆包(散集)，远程对象需要注意正确协同多个对象中的共享状态，以及对远程对象本身状态的访问；
    * Swing/AWT：GUI应用程序通常会为每个事件分配一个单独的事件处理器线程；


## 线程安全性：
* 编写线程安全的代码核心在于对状态访问操作进行管理（特别是对共享和可变状态的访问），当多个线程访问某个状态变量且涉及写入修改操作时，必须采用同步机制来协同这些线程对变量的访问，如java中的主要同步机制关键字synchronized(提供一种独占的加锁方式)，
  此外同步还包括volatile类型变量，显示锁以及原子变量。
* 通常将程序状态封装在一个类中，程序状态良好的封装性有助于实现程序的线程安全性；
* 线程安全类：当多个线程访问某个类时，这个类始终都能表现出正确的行为，则说这个类线程安全（核心为正确性，指某个类的行为与其规范完全一致，在良好的规范中通常会定义各种不变性条件和约束对象的状态，以及各种后验条件来约束对象操作的结果）。

* 原子性：
    * 竞态条件： 当某个计算的正确性取决于多个线程交替执行的时序，会发生竞态条件（结果具有偶然性），常见的竞态条件类型为先检查在执行，本质为可能基于一个失效的状态来做出判断或执行计算，为避免竞态条件错误结果的出现需要将一组复合操作
    变为原子操作(执行过程不可打断)

## 加锁机制：
* 多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。当不变性条件涉及多个变量时，某个变量的值会对其他变量产生约束，则为保证线程安全和状态一致性，当更新一个变量时，需要在同一个原子操作中对相关变量进行更新。
* 内置锁：
    * 同步代码块，包括作为锁的对象引用和由这个锁保护的同步代码块（如由关键字synchronized修饰的方法为一个横跨整个方法体的同步代码块，锁为方法调用所在的对象，静态的synchronized方法以class对象作为锁）
    * java中的每个对的每个对象都可以用作实现同步的锁，称为内置锁或监视器锁。线程在进入同步代码块时自动获得锁，在退出同步代码块时自动释放所。
    * 内置锁为互斥锁，保证每次只能由一个线程获得，当另一个线程想要获得被其他线程持有的锁时，必需阻塞等待，直到该锁被释放。因此内置锁可以保证同步代码块以原子方式执行
* 重入：
     * 内置锁可重入，意味着一个线程可以获得已由它本身持有的锁，获得锁的粒度是线程，而不是调用。
     * 实现方法，通常为每个锁关联一个获取计数值和所有者对象；
     * 重入提高加锁行为的封装性，如避免的当子类重写父类的synchronized方法，调用父类中的方法时出现死锁情况的发生
* 用锁保护状态：
    * 锁能保证代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问，确保状态的一致性 
    * 通常将所有可变状态封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得该对象上不会发生并发访问
    * 对于每个包含多个变量的不变性条件，其中涉及的所有变量都应该由一个锁来保护。
* 活跃性与性能：粗粒度加锁行为，可能影响程序的并发性，另外获得/释放锁同样需要一定的性能开销，粒度过细的加锁行为也会影响程序性能，在利用加锁来进行同步控制时，应注意程序简单性与并发性的平衡，提高程序性能。

## 对象共享：
* 可见性:当读/写操作不在一个线程中时，一个线程的写入的最新结果未必可以在另一个线程立即读到(读到的可能为过期的失效值)，为确保多个线程对内存写入操作的可见性，需要使用同步机制。
* 非原子的64位操作：JVM内存模型要求，对于读/写操作都必须是原子操作，但对于64位的非volatile变量读/写操作会被分解为两个32位的操作（因此对于一个64位的变量，如果读/写操作不在一个线程中，则可能出现读到的一个数值的高32位为写入前的失效值，低32位为写入后的最新值的情况） 
* 加锁与可见性：内置锁可以确保一个线程以可预测的方式来查看另一个线程的执行结果(对于同一个同步代码块，读线程线程在获得锁后，可以之前写线程对该同步代码块的所有操作结果)
* volatile变量：相比内置锁，一种更弱的同步机制，确保将变量的更细操作通知其他线程：
    * 对于valatile类型的变量，编译器或在运行时会注意到此变量共享，因此不会将该变量上的操作与其他内存操作一起重排序。同时volatile变量的值不会缓存在寄存器或其他处理器不可见的地方，因此在读取volatile类型变量的值时总会得到最新写入的值。(在操作volatile类型变量时不会执行加锁操作，因此不会出现线程阻塞，)
    * 不应过分依赖volatile实现同步机制，通常当volatileb能过简化代码的实现以及对同步策略的验证时使用，通常用作某个操作完成，发生中断或者状态的标记，如检查某个状态标记以判断是否退出循环。
* 发布与逸出：
    * 发布是指使对象能够在当前作用域之外使用，如将一个指向该对象的引用保存在其他代码可以访问到的地方，或者通过一个非私有的方法返回该对象的引用。
    * 发布内部状态可能会破坏封装性，使得程序难以维持不变性条件。当某个不应该被发布的对象被发布时，称为逸出。
    * 同时当发布某个对象时可能会间接的发布其他对象,如当发布一个对象时，该对象的所有私有域中所引用的对象均会被发布；当发布一个对象的内部的类实例时，也隐含的发布的该对象实例本身，因为内部类的实例中包含了对该对象实例的隐含引用。
    * 安全的对象构造过程:当且仅当对象的构造函数返回时，该对象才处于可预测和一致性状态。因此当在构造函数中发布对象时，只是发布了一个尚未构造完成的对象。如果this引用在构造过程中逸出，这种情况被认为是不正确的构造，如构造函数中启动一个线程
* 线程封闭：
    * 仅在单个线程中访问数据，称为线程封闭，是实现线程安全最简单的方式之一。(如swing非事件分发线程，JDBC中的Connection对象被封闭在单个线程中)
    * Java语言及其核心库提供了一些机制来维持线程封闭性，如局部变量和ThreadLocal类
    * Ad-hoc线程封闭:指维护线程封闭的职责完全由程序实现，如可见性修饰的局部变量能将对象修饰到目标线程中。对于volatile变量只要保证在单个线程对其进行写操作，就可以保证该变量的线程安全，可以安全的在这些共享的volatile变量上执行读/写/改操作；
    * 栈封闭: 只有通过局部变量才可以访问对象。局部变量固有属性之一就是封闭在线程中，位于其他线程无法访问的线程栈中。栈封闭相比Ad-hoc更加健壮，更易维护；
    * 维护线程封闭的一种更规范的方法是使用ThreadLocal类，该类能使线程中的某个值与保存值的对象关联起来，提供get()/set()接口方法，为每个使用该变量的线程都拥有一个独立的副本，因此get()总返回当前线程的set()设置的最新值。通常用于对可变单实例变量或全局变量进行共享。当某个频繁执行的操作需要一个临时对象，如缓冲区，同时又希望在每次执行时都重新分配该临时变量，可以使用ThreadLocal;
*  不变性：
    * 如果某个对象在创建后其状态不能被修改，则这个对象被称为不可变对象。不可变对象一定线程安全；不可变性并不等于对象的所有域都声明为final(在final域中可能保存对可变对象的引用)，
    * 不变性需要满足以下条件：创建后状态不能更改/所有域都是final类型/对象正确创建(创建期间this指针没有逸出)
    * 同时不可变对象的内部仍可以使用可变对象来管理，但需要保证屏蔽可变对象的修改操作；
    * 某些情况下，不可变对象可以提供弱形式的原子性，为避免在访问和更新多个相关变量时出现数据竞争条件，可以将这些所有的相关变量保存在保存在一个不可变对象中(可以通过创建多个新的容器对象更新这些变量，并使用一个volatile类型的变量确保其可见性，此时其他使用原有对象的线程仍会看到对象处于一致性状态，更新时可改变volatile类型的引用指向).
> 不可变性并不需要把所有的域声明为final,有时需要对良性数据竞争做分析，如String会将散列值计算推迟到第一次调用hash code,并将计算得到的散列值缓存在非final类型域中   
* 安全发布:
    * 不正确的发布，如多线程共享对象时，没有使用同机制确保共享对象的可见性，其他线程可能得到未创建完成/不一致/失效的变量状态。
    * Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证(即使对象的引用对其他线程可见但并不意味着对象状态对使用该对象的线程一定可见，需要使用同步确保对象状态的一致性)，为维持初始化安全性的保证，需满足：状态不可修改/所有域均为final/正确的构造
    * 可变对象必须通过安全的方式来发布，通常在发布和使用该对象的线程时使用同步。
    * 要安全的发布对象，需保证对象的引用和状态必须同时对其他线程可见，一个正确构造的对象可通过以下方式安全发布:
        * 在静态初始化函数中初始化一个对象的引用
        * 将对象的引用保存在volatile类型的域或者AtomicReference对象中。
        * 将对象的引用保存到正确构造的对象的final域中
        * 将对象的引用保存到一个由锁保护的域中(如线程安全容器Vector/synchronizedList)
    * 通常使用静态初始化器发布静态构造对象，静态初始化器由JVM在类的初始化阶段执行，在JVM内部存在着同步机制，因此这种方式初始化的对象可以安全发布。
    * 不可变对象可以安全发布。如果一个对象技术上是可变的，但保证其状态发布后状态不会再改变，这种对象称为事实不可变对象。(对于可变对象，不仅发布时需要同步，每次访问时同样需要同步来保证后续操作的可见性)
> 线程安全库中的容器类提供以下安全发布保证:1.将一个键或值放入，HashTable/synchronizedMap或ConcurrentMap中，可以安全的将它发布给从这些容器中访问它的线程。2.将某个元素放入Vector,CopyOnWriteArrayList,CopyOnWriteArraySet，synchronizedList，synchronizedSet中。可以安全的将它发布给从这些容器访问它的线程。3.将元素放入BlockingQueue/ConcurrentLinkQueue中可以将对象安全的发布到任何从这些队列(类库中的其他数据传递机制,如Future/Exchanage,同样能实现安全发布)
* 在并发程序中使用和共享对象时，需要使用一些策略:
    * 线程封闭:只能由一个线程拥有，该对象对象封闭在线程中，且只能由这个线程修改。
    * 只读共享:共享的只读对象可以由多个线程并发访问(不要额外的同步机制)，但不能修改。包括不可变对象和事实不可变对象。
    * 线程安全共享:线程安全对象在其内部实现同步，因此多个线程可通过对象的公有接口进行访问，而不需要其他同步。
    * 保护对象:被保护的对象只能通过持有特定的锁来访问。包括封装在其他线程安全对象中对象，以及已发布的由某个锁保护的对象。

## 对象的组合:
* 将现有线程安全组件组合为更大规模的组件或程序。
* 设计线程安全的类通常包含以下要素:
    * 1.找出构成对象的所有变量（区别基本类型／引用类型，对于引用类型对象状态同样包含引用对象的域）；
    * ２.找出约束状态变量的不变性条件；
    * ３．建立对象状态的并发访问状态管理；
    * 收集同步需求:对象与变量的所有取值称为其状态空间，许多类中都定义了一些变量性条件限制状态空间的大小，此外有些包含后验条件判断状态迁移是否有效(如：当下一个状态需要依赖当前状态时，迁移操作必须为复合操作，当不变性条件涉及多个变量时，这些相关变量必须在原子操作中读取／操作)   
    * 依赖状态的操作:类的不变性条件和后验条件约束了在对象上哪些状态转换是有效的。某些对象上包含基于状态的先验条件(如从队列移除一个元素前队列必须非空)，如果在某个操作中有基于状态的先验条件，这个操作称为依赖状态的操作，
        * 对于依赖状态的操作，先并发程序中必须要对应先验条件变为真才可以执行此类操作，可以借助类库中的类实现依赖状态的行为(如阻塞队列BlockQueue/信号量Semaphore等)；
    * 状态所有权：在考虑对象的状态包含的变量时，只需考虑对象拥有的数据，即所有权；(Java的垃圾回收器降低了所有权处理的开销，在C++中把一个对象传递给一个方法时，需考虑该操作是否传递对象的所有权，长期or短期)
        * 所有权与封装相关联，对象封装其拥有的状态，即对封装的状态拥有所有权。同时所有权意味着控制权(状态变量所有者决定采用何种加锁协议维持变量状态的完整性)，所有权分为独享or共享(状态变量被发布)，容器类通常表现出一种所有权分离的形式。 
* 实例封闭:　将一个对象封装在另一个对象中(如私有域／局部变量／或封闭在线程内)，从而将另一个对象的访问限制在该对象的方法上，访问可控，通过封闭机制与合适的加锁机制结合，可以确保以线程安全的方式来使用非线程安全对象
    * 实例封闭使得锁策略的选择更加灵活，同时使得不同的状态变量可以由不同的锁来保护
    * Java平台类库存在很多线程封闭实例，如包装器工厂方法(如Collections.synchronizedList等类似方法)使得一些容器等非线程安全的类可以在多线程安全环境下安全使用。(通过装饰器模式将容器类封装在一个同步的包装器对象中，包装器可将接口中的每个方法实现为同步方法，将调用请求转发给底层的容器对象，只要包装器对象拥有底层容器的唯一引用便可实现线程安全)
    * java监视器模式:遵循Java监视器模式的对象会把对象的所有可变状态都封装起来并由对象内置的锁来保护，是一种编程约定，如Vector,HashTable等很多类都使用了该模式(可在对象内部，利用私有锁保护对象状态，不同于对象的内置锁，对象可以将私有锁封装起来，客户代码只有通过提供的公有方法访问锁，以便参与到它的同步策略)
        * Java监视器模式，适合从头开始构建一个类，或将多个非线程安全的类组合为一个类时保证线程安全。
* 线程安全性的委托:通过将多个线程安全的类组合而成的类未必线程安全。
    * 可以将对象的状态委托给内部一个线程安全的对象来管理，从而实现线程安全。此外可以将线程安全性委托给多个状态变量，但需要这些变量彼此独立(独立的状态变量,即组合而成的类不会在其包含的多个状态变量上增加不变性条件)
    * 多状态委托涉及的多个变量存在不变性约束条件时，对于单个变量的修改可能破坏变量间的约束条件，从而组合得到的类为非线程安全。此时需要必要的加锁机制来维护变量间的不变性条件，将涉及多个变量状态的复合操作限制为原子操作(除非整个符合操作都可以委托给某个线程安全的状态变量)
    * 应根据委托的底层变量上施加的不变性条件，决定状态的发布(对于本身线程安全，且没有不变性条件约束，不存在任务无效状态转换，则可以安全发布)
* 在现有的线程安全类中添加功能:在开发中我们通常选择重用类库中一些现有的基础功能类，但有时可能现有的类不能满足我们全部的功能需求，此时需要我们在不破坏原来类的线程安全性的情况下，增加一些新的功能操作，可以选择扩展子类实现(也可以修改源代码实现)。
    * 在扩展类的功能时，应保证扩展的同步与原有类的同步相配合(原有类的同步策略的改变可能破坏扩展类的线程安全，如锁的不一致)，客户端加锁(类组合)与扩展类加锁(类继承)均将派生类的行为与基类的实现耦合在一起，可能会破坏同步策略的封装性；
    * 组合(类组合+类继承)；通过自身的内置锁增加一层额外的加锁，并不关心底层的基类是否线程安全。
* 在工程设计阶段应注意将同步策略文档化，文档中注意说明需要了解的线程安全性保证，同步策略，如volatile/加锁，哪些锁保护哪些变量，哪些变量可变或封闭在线程中，哪操作必须为原子操作等。
> 同步策略定义了如何在不违背对象不变性条件或后验条件的情况下对其状态访问操作进行协同，规定了如何将不变性／线程封闭／加锁机制等结合以维护线程安全性，规定了哪些变量由哪些锁保护 


## 基础构建模块
* 将线程安全性委托给一些现有的线程安全类是创建线程安全类的一个有效的策略,Java平台类库包含丰富的并发基础的模块，如线程安全的容器类以及各种用于协调多个相互协作线程控制流的同步工具类。
### 同步容器类:
* 包括Vector和Hashtable(以及其他功能相似的类),这些同步的封装器由Collection.synchronizedXXX更工厂方法创建，实现线程安全的方式是:将对象的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态.
* 在某些情况下，可能需要额外的客户端加锁来保护涉及线程安全的复合操作(如迭代/跳转/条件运算等)
* 迭代器与ConcurrentModificationException: 对于同步容器类的迭代器，表现出及时失败的行为，在进行迭代时当发现容器被修改，会抛出一个ConcurrentModificationException异常，采用的实现方式是：将计数器的变化与容器关联起来，如果在迭代期间计数器被修改，则hasNext或next将抛出该异常。为避免该异常的出现，可以在迭代过程中持有容器的锁或“克隆"容器，并在副本上进行迭代(副本被封闭在线程内)；
* 隐藏迭代器: 某些情况下可能会隐式的执行容器的迭代操作(如在抵用容器的toString()方法时会迭代容器，对其中的每个元素调用toString(),此外当容器作为另一个容器的元素或键值时，容器的hashCode()/equal()也会间接执行迭代操作;还有containsALl(),removeAll(),retainAll()等方法以及把容器作为参数的构造函数)
## 
> 然而为了降低并发修改操作的检测代码带来的程序性能的影响，计数器的检检查并没有同步，因此迭代器可能得到失效的计数值，