# JAVA并发编程实战

## 概述：
* 多线程优势：
    * 并发程序可以使复杂的异步代码变得更加简单（异步性指当任务划分为更细粒度时，在不影响本次任务的前提下，可同时进行其他任务），通过线程可以将复杂异步的工作流分解为一组简单且同步的工作流，每个工作流在一个单独的线程中运行，在特定位置同步；
    * 同时多线程可以充分利用处理器的计算资源（线程在共享进程资源的同时，拥有各自的PC，栈和局部变量，为计算机基本的调度单位，相同进程的多个线程可在不同CPU上运行）。
* 线程安全：当多个线程共享变量，需要操作相同的内存地址，可能由于无法预料的执行顺序发生错误,此时需要利用同步机制对涉及共享变量的操作加以协同（如i++并非线程安全（会出现竞争条件），它可以分解为三个操作：1读取，2加一，3写回）

* 其他：
    * 进程间通信机制：套接字，信号处理器，共享内存，信号量以及文件等；
    * 活跃性问题: 指程序永远不能结束，如串行程序中的无限循环，多线程中的死锁，饥饿，活锁等；
    * 处理不当多线程可能会影响程序性能，多线程调度可能导致频繁的上下文切换，同步机制等需要额外的性能开销，
* 线程无处不在，当我们调用一些多线程相关的模块框架时，在整个程序中应注意与之相关的线程安全问题，如：
    * Timer类:主要用于线程定时调度，管理线程的执行时间
    * Servlet/JSP:主要用来处理请求，通常会为一个请求分配一个单独的处理线程；
    * RMI远程方法调用: 必须将传递的参数打包(列集)，然后由远程JVM拆包(散集)，远程对象需要注意正确协同多个对象中的共享状态，以及对远程对象本身状态的访问；
    * Swing/AWT：GUI应用程序通常会为每个事件分配一个单独的事件处理器线程；


## 线程安全性：
* 编写线程安全的代码核心在于对状态访问操作进行管理（特别是对共享和可变状态的访问），当多个线程访问某个状态变量且涉及写入修改操作时，必须采用同步机制来协同这些线程对变量的访问，如java中的主要同步机制关键字synchronized(提供一种独占的加锁方式)，
  此外同步还包括volatile类型变量，显示锁以及原子变量。
* 通常将程序状态封装在一个类中，程序状态良好的封装性有助于实现程序的线程安全性；
* 线程安全类：当多个线程访问某个类时，这个类始终都能表现出正确的行为，则说这个类线程安全（核心为正确性，指某个类的行为与其规范完全一致，在良好的规范中通常会定义各种不变性条件和约束对象的状态，以及各种后验条件来约束对象操作的结果）。

* 原子性：
    * 竞态条件： 当某个计算的正确性取决于多个线程交替执行的时序，会发生竞态条件（结果具有偶然性），常见的竞态条件类型为先检查在执行，本质为可能基于一个失效的状态来做出判断或执行计算，为避免竞态条件错误结果的出现需要将一组复合操作
    变为原子操作(执行过程不可打断)

## 加锁机制：
* 多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。当不变性条件涉及多个变量时，某个变量的值会对其他变量产生约束，则为保证线程安全和状态一致性，当更新一个变量时，需要在同一个原子操作中对相关变量进行更新。
* 内置锁：
    * 同步代码块，包括作为锁的对象引用和由这个锁保护的同步代码块（如由关键字synchronized修饰的方法为一个横跨整个方法体的同步代码块，锁为方法调用所在的对象，静态的synchronized方法以class对象作为锁）
    * java中的每个对的每个对象都可以用作实现同步的锁，称为内置锁或监视器锁。线程在进入同步代码块时自动获得锁，在退出同步代码块时自动释放所。
    * 内置锁为互斥锁，保证每次只能由一个线程获得，当另一个线程想要获得被其他线程持有的锁时，必需阻塞等待，直到该锁被释放。因此内置锁可以保证同步代码块以原子方式执行
* 重入：
     * 内置锁可重入，意味着一个线程可以获得已由它本身持有的锁，获得锁的粒度是线程，而不是调用。
     * 实现方法，通常为每个锁关联一个获取计数值和所有者对象；
     * 重入提高加锁行为的封装性，如避免的当子类重写父类的synchronized方法，调用父类中的方法时出现死锁情况的发生
* 用锁保护状态：
    * 锁能保证代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问，确保状态的一致性 
    * 通常将所有可变状态封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得该对象上不会发生并发访问
    * 对于每个包含多个变量的不变性条件，其中涉及的所有变量都应该由一个锁来保护。
* 活跃性与性能：粗粒度加锁行为，可能影响程序的并发性，另外获得/释放锁同样需要一定的性能开销，粒度过细的加锁行为也会影响程序性能，在利用加锁来进行同步控制时，应注意程序简单性与并发性的平衡，提高程序性能。

## 对象共享：
* 可见性:当读/写操作不在一个线程中时，一个线程的写入的最新结果未必可以在另一个线程立即读到(读到的可能为过期的失效值)，为确保多个线程对内存写入操作的可见性，需要使用同步机制。
* 非原子的64位操作：JVM内存模型要求，对于读/写操作都必须是原子操作，但对于64位的非volatile变量读/写操作会被分解为两个32位的操作（因此对于一个64位的变量，如果读/写操作不在一个线程中，则可能出现读到的一个数值的高32位为写入前的失效值，低32位为写入后的最新值的情况） 
* 加锁与可见性：内置锁可以确保一个线程以可预测的方式来查看另一个线程的执行结果(对于同一个同步代码块，读线程线程在获得锁后，可以之前写线程对该同步代码块的所有操作结果)
* volatile变量：相比内置锁，一种更弱的同步机制，确保将变量的更细操作通知其他线程：
    * 对于valatile类型的变量，编译器或在运行时会注意到此变量共享，因此不会将该变量上的操作与其他内存操作一起重排序。同时volatile变量的值不会缓存在寄存器或其他处理器不可见的地方，因此在读取volatile类型变量的值时总会得到最新写入的值。(在操作volatile类型变量时不会执行加锁操作，因此不会出现线程阻塞，)
    * 不应过分依赖volatile实现同步机制，通常当volatileb能过简化代码的实现以及对同步策略的验证时使用，通常用作某个操作完成，发生中断或者状态的标记，如检查某个状态标记以判断是否退出循环。
* 发布与逸出：
    * 发布是指使对象能够在当前作用域之外使用，如将一个指向该对象的引用保存在其他代码可以访问到的地方，或者通过一个非私有的方法返回该对象的引用。
    * 发布内部状态可能会破坏封装性，使得程序难以维持不变性条件。当某个不应该被发布的对象被发布时，称为逸出。
    * 同时当发布某个对象时可能会间接的发布其他对象,如当发布一个对象时，该对象的所有私有域中所引用的对象均会被发布；当发布一个对象的内部的类实例时，也隐含的发布的该对象实例本身，因为内部类的实例中包含了对该对象实例的隐含引用。
    * 安全的对象构造过程:当且仅当对象的构造函数返回时，该对象才处于可预测和一致性状态。因此当在构造函数中发布对象时，只是发布了一个尚未构造完成的对象。如果this引用在构造过程中逸出，这种情况被认为是不正确的构造，如构造函数中启动一个线程
* 线程封闭：
    * 仅在单个线程中访问数据，称为线程封闭，是实现线程安全最简单的方式之一。(如swing非事件分发线程，JDBC中的Connection对象被封闭在单个线程中)
    * Java语言及其核心库提供了一些机制来维持线程封闭性，如局部变量和ThreadLocal类
    * Ad-hoc线程封闭:指维护线程封闭的职责完全由程序实现，如可见性修饰的局部变量能将对象修饰到目标线程中。对于volatile变量只要保证在单个线程对其进行写操作，就可以保证该变量的线程安全，可以安全的在这些共享的volatile变量上执行读/写/改操作；
    * 栈封闭: 只有通过局部变量才可以访问对象。局部变量固有属性之一就是封闭在线程中，位于其他线程无法访问的线程栈中。栈封闭相比Ad-hoc更加健壮，更易维护；
    * 维护线程封闭的一种更规范的方法是使用ThreadLocal类，该类能使线程中的某个值与保存值的对象关联起来，提供get()/set()接口方法，为每个使用该变量的线程都拥有一个独立的副本，因此get()总返回当前线程的set()设置的最新值。通常用于对可变单实例变量或全局变量进行共享。当某个频繁执行的操作需要一个临时对象，如缓冲区，同时又希望在每次执行时都重新分配该临时变量，可以使用ThreadLocal;
*  不变性：
    * 如果某个对象在创建后其状态不能被修改，则这个对象被称为不可变对象。不可变对象一定线程安全；不可变性并不等于对象的所有域都声明为final(在final域中可能保存对可变对象的引用)，
    * 不变性需要满足以下条件：创建后状态不能更改/所有域都是final类型/对象正确创建(创建期间this指针没有逸出)
    * 同时不可变对象的内部仍可以使用可变对象来管理，但需要保证屏蔽可变对象的修改操作；
    * 某些情况下，不可变对象可以提供弱形式的原子性，为避免在访问和更新多个相关变量时出现数据竞争条件，可以将这些所有的相关变量保存在保存在一个不可变对象中(可以通过创建多个新的容器对象更新这些变量，并使用一个volatile类型的变量确保其可见性，此时其他使用原有对象的线程仍会看到对象处于一致性状态，更新时可改变volatile类型的引用指向).
> 不可变性并不需要把所有的域声明为final,有时需要对良性数据竞争做分析，如String会将散列值计算推迟到第一次调用hash code,并将计算得到的散列值缓存在非final类型域中   
* 安全发布:
    * 不正确的发布，如多线程共享对象时，没有使用同机制确保共享对象的可见性，其他线程可能得到未创建完成/不一致/失效的变量状态。
    * Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证(即使对象的引用对其他线程可见但并不意味着对象状态对使用该对象的线程一定可见，需要使用同步确保对象状态的一致性)，为维持初始化安全性的保证，需满足：状态不可修改/所有域均为final/正确的构造
    * 可变对象必须通过安全的方式来发布，通常在发布和使用该对象的线程时使用同步。
    * 要安全的发布对象，需保证对象的引用和状态必须同时对其他线程可见，一个正确构造的对象可通过以下方式安全发布:
        * 在静态初始化函数中初始化一个对象的引用
        * 将对象的引用保存在volatile类型的域或者AtomicReference对象中。
        * 将对象的引用保存到正确构造的对象的final域中
        * 将对象的引用保存到一个由锁保护的域中(如线程安全容器Vector/synchronizedList)
    * 通常使用静态初始化器发布静态构造对象，静态初始化器由JVM在类的初始化阶段执行，在JVM内部存在着同步机制，因此这种方式初始化的对象可以安全发布。
    * 不可变对象可以安全发布。如果一个对象技术上是可变的，但保证其状态发布后状态不会再改变，这种对象称为事实不可变对象。(对于可变对象，不仅发布时需要同步，每次访问时同样需要同步来保证后续操作的可见性)
> 线程安全库中的容器类提供以下安全发布保证:1.将一个键或值放入，HashTable/synchronizedMap或ConcurrentMap中，可以安全的将它发布给从这些容器中访问它的线程。2.将某个元素放入Vector,CopyOnWriteArrayList,CopyOnWriteArraySet，synchronizedList，synchronizedSet中。可以安全的将它发布给从这些容器访问它的线程。3.将元素放入BlockingQueue/ConcurrentLinkQueue中可以将对象安全的发布到任何从这些队列(类库中的其他数据传递机制,如Future/Exchanage,同样能实现安全发布)
* 在并发程序中使用和共享对象时，需要使用一些策略:
    * 线程封闭:只能由一个线程拥有，该对象对象封闭在线程中，且只能由这个线程修改。
    * 只读共享:共享的只读对象可以由多个线程并发访问(不要额外的同步机制)，但不能修改。包括不可变对象和事实不可变对象。
    * 线程安全共享:线程安全对象在其内部实现同步，因此多个线程可通过对象的公有接口进行访问，而不需要其他同步。
    * 保护对象:被保护的对象只能通过持有特定的锁来访问。包括封装在其他线程安全对象中对象，以及已发布的由某个锁保护的对象。

## 对象的组合:
* 将现有线程安全组件组合为更大规模的组件或程序。
* 设计线程安全的类通常包含以下要素:
    * 1.找出构成对象的所有变量（区别基本类型／引用类型，对于引用类型对象状态同样包含引用对象的域）；
    * ２.找出约束状态变量的不变性条件；
    * ３．建立对象状态的并发访问状态管理；
    * 收集同步需求:对象与变量的所有取值称为其状态空间，许多类中都定义了一些变量性条件限制状态空间的大小，此外有些包含后验条件判断状态迁移是否有效(如：当下一个状态需要依赖当前状态时，迁移操作必须为复合操作，当不变性条件涉及多个变量时，这些相关变量必须在原子操作中读取／操作)   
    * 依赖状态的操作:
> 同步策略定义了如何在不违背对象不变性条件或后验条件的情况下对其状态访问操作进行协同，规定了如何将不变性／线程封闭／加锁机制等结合以维护线程安全性，规定了哪些变量由哪些锁保护 
