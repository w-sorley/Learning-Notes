
# JAVA并发编程实战
## 概述：
* 多线程优势：
    * 并发程序可以使复杂的异步代码变得更加简单（异步性指当任务划分为更细粒度时，在不影响本次任务的前提下，可同时进行其他任务），通过线程可以将复杂异步的工作流分解为一组简单且同步的工作流，每个工作流在一个单独的线程中运行，在特定位置同步；
    * 同时多线程可以充分利用处理器的计算资源（线程在共享进程资源的同时，拥有各自的PC，栈和局部变量，为计算机基本的调度单位，相同进程的多个线程可在不同CPU上运行）。
* 线程安全：当多个线程共享变量，需要操作相同的内存地址，可能由于无法预料的执行顺序发生错误,此时需要利用同步机制对涉及共享变量的操作加以协同（如i++并非线程安全（会出现竞争条件），它可以分解为三个操作：1读取，2加一，3写回）

* 其他：
    * 进程间通信机制：套接字，信号处理器，共享内存，信号量以及文件等；
    * 活跃性问题: 指程序永远不能结束，如串行程序中的无限循环，多线程中的死锁，饥饿，活锁等；
    * 处理不当多线程可能会影响程序性能，多线程调度可能导致频繁的上下文切换，同步机制等需要额外的性能开销，
* 线程无处不在，当我们调用一些多线程相关的模块框架时，在整个程序中应注意与之相关的线程安全问题，如：
    * Timer类:主要用于线程定时调度，管理线程的执行时间
    * Servlet/JSP:主要用来处理请求，通常会为一个请求分配一个单独的处理线程；
    * RMI远程方法调用: 必须将传递的参数打包(列集)，然后由远程JVM拆包(散集)，远程对象需要注意正确协同多个对象中的共享状态，以及对远程对象本身状态的访问；
    * Swing/AWT：GUI应用程序通常会为每个事件分配一个单独的事件处理器线程；


## 线程安全性：
* 编写线程安全的代码核心在于对状态访问操作进行管理（特别是对共享和可变状态的访问），当多个线程访问某个状态变量且涉及写入修改操作时，必须采用同步机制来协同这些线程对变量的访问，如java中的主要同步机制关键字synchronized(提供一种独占的加锁方式)，
  此外同步还包括volatile类型变量，显示锁以及原子变量。
* 通常将程序状态封装在一个类中，程序状态良好的封装性有助于实现程序的线程安全性；
* 线程安全类：当多个线程访问某个类时，这个类始终都能表现出正确的行为，则说这个类线程安全（核心为正确性，指某个类的行为与其规范完全一致，在良好的规范中通常会定义各种不变性条件和约束对象的状态，以及各种后验条件来约束对象操作的结果）。

* 原子性：
    * 竞态条件： 当某个计算的正确性取决于多个线程交替执行的时序，会发生竞态条件（结果具有偶然性），常见的竞态条件类型为先检查在执行，本质为可能基于一个失效的状态来做出判断或执行计算，为避免竞态条件错误结果的出现需要将一组复合操作
    变为原子操作(执行过程不可打断)

## 加锁机制：
* 多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。当不变性条件涉及多个变量时，某个变量的值会对其他变量产生约束，则为保证线程安全和状态一致性，当更新一个变量时，需要在同一个原子操作中对相关变量进行更新。
* 内置锁：
    * 同步代码块，包括作为锁的对象引用和由这个锁保护的同步代码块（如由关键字synchronized修饰的方法为一个横跨整个方法体的同步代码块，锁为方法调用所在的对象，静态的synchronized方法以class对象作为锁）
    * java中的每个对的每个对象都可以用作实现同步的锁，称为内置锁或监视器锁。线程在进入同步代码块时自动获得锁，在退出同步代码块时自动释放所。
    * 内置锁为互斥锁，保证每次只能由一个线程获得，当另一个线程想要获得被其他线程持有的锁时，必需阻塞等待，直到该锁被释放。因此内置锁可以保证同步代码块以原子方式执行
* 重入：
     * 内置锁可重入，意味着一个线程可以获得已由它本身持有的锁，获得锁的粒度是线程，而不是调用。
     * 实现方法，通常为每个锁关联一个获取计数值和所有者对象；
     * 重入提高加锁行为的封装性，如避免的当子类重写父类的synchronized方法，调用父类中的方法时出现死锁情况的发生
* 用锁保护状态：
    * 锁能保证代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问，确保状态的一致性 
    * 通常将所有可变状态封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得该对象上不会发生并发访问
    * 对于每个包含多个变量的不变性条件，其中涉及的所有变量都应该由一个锁来保护。
* 活跃性与性能：粗粒度加锁行为，可能影响程序的并发性，另外获得/释放锁同样需要一定的性能开销，粒度过细的加锁行为也会影响程序性能，在利用加锁来进行同步控制时，应注意程序简单性与并发性的平衡，提高程序性能。

## 对象共享：
* 可见性:当读/写操作不在一个线程中时，一个线程的写入的最新结果未必可以在另一个线程立即读到(读到的可能为过期的失效值)，为确保多个线程对内存写入操作的可见性，需要使用同步机制。
* 非原子的64位操作：JVM内存模型要求，对于读/写操作都必须是原子操作，但对于64位的非volatile变量读/写操作会被分解为两个32位的操作（因此对于一个64位的变量，如果读/写操作不在一个线程中，则可能出现读到的一个数值的高32位为写入前的失效值，低32位为写入后的最新值的情况） 
* 加锁与可见性：内置锁可以确保一个线程以可预测的方式来查看另一个线程的执行结果(对于同一个同步代码块，读线程线程在获得锁后，可以之前写线程对该同步代码块的所有操作结果)
* volatile变量：相比内置锁，一种更弱的同步机制，确保将变量的更细操作通知其他线程：
    * 对于valatile类型的变量，编译器或在运行时会注意到此变量共享，因此不会将该变量上的操作与其他内存操作一起重排序。同时volatile变量的值不会缓存在寄存器或其他处理器不可见的地方，因此在读取volatile类型变量的值时总会得到最新写入的值。(在操作volatile类型变量时不会执行加锁操作，因此不会出现线程阻塞，)
    * 不应过分依赖volatile实现同步机制，通常当volatileb能过简化代码的实现以及对同步策略的验证时使用，通常用作某个操作完成，发生中断或者状态的标记，如检查某个状态标记以判断是否退出循环。
* 发布与逸出：
    * 发布是指使对象能够在当前作用域之外使用，如将一个指向该对象的引用保存在其他代码可以访问到的地方，或者通过一个非私有的方法返回该对象的引用。
    * 发布内部状态可能会破坏封装性，使得程序难以维持不变性条件。当某个不应该被发布的对象被发布时，称为逸出。
    * 同时当发布某个对象时可能会间接的发布其他对象,如当发布一个对象时，该对象的所有私有域中所引用的对象均会被发布；当发布一个对象的内部的类实例时，也隐含的发布的该对象实例本身，因为内部类的实例中包含了对该对象实例的隐含引用。
    * 安全的对象构造过程:当且仅当对象的构造函数返回时，该对象才处于可预测和一致性状态。因此当在构造函数中发布对象时，只是发布了一个尚未构造完成的对象。如果this引用在构造过程中逸出，这种情况被认为是不正确的构造，如构造函数中启动一个线程
* 线程封闭：
    * 仅在单个线程中访问数据，称为线程封闭，是实现线程安全最简单的方式之一。(如swing非事件分发线程，JDBC中的Connection对象被封闭在单个线程中)
    * Java语言及其核心库提供了一些机制来维持线程封闭性，如局部变量和ThreadLocal类
    * Ad-hoc线程封闭:指维护线程封闭的职责完全由程序实现，如可见性修饰的局部变量能将对象修饰到目标线程中。对于volatile变量只要保证在单个线程对其进行写操作，就可以保证该变量的线程安全，可以安全的在这些共享的volatile变量上执行读/写/改操作；
    * 栈封闭: 只有通过局部变量才可以访问对象。局部变量固有属性之一就是封闭在线程中，位于其他线程无法访问的线程栈中。栈封闭相比Ad-hoc更加健壮，更易维护；
    * 维护线程封闭的一种更规范的方法是使用ThreadLocal类，该类能使线程中的某个值与保存值的对象关联起来，提供get()/set()接口方法，为每个使用该变量的线程都拥有一个独立的副本，因此get()总返回当前线程的set()设置的最新值。通常用于对可变单实例变量或全局变量进行共享。当某个频繁执行的操作需要一个临时对象，如缓冲区，同时又希望在每次执行时都重新分配该临时变量，可以使用ThreadLocal;
*  不变性：
    * 如果某个对象在创建后其状态不能被修改，则这个对象被称为不可变对象。不可变对象一定线程安全；不可变性并不等于对象的所有域都声明为final(在final域中可能保存对可变对象的引用)，
    * 不变性需要满足以下条件：创建后状态不能更改/所有域都是final类型/对象正确创建(创建期间this指针没有逸出)
    * 同时不可变对象的内部仍可以使用可变对象来管理，但需要保证屏蔽可变对象的修改操作；
    * 某些情况下，不可变对象可以提供弱形式的原子性，为避免在访问和更新多个相关变量时出现数据竞争条件，可以将这些所有的相关变量保存在保存在一个不可变对象中(可以通过创建多个新的容器对象更新这些变量，并使用一个volatile类型的变量确保其可见性，此时其他使用原有对象的线程仍会看到对象处于一致性状态，更新时可改变volatile类型的引用指向).
> 不可变性并不需要把所有的域声明为final,有时需要对良性数据竞争做分析，如String会将散列值计算推迟到第一次调用hash code,并将计算得到的散列值缓存在非final类型域中   
* 安全发布:
    * 不正确的发布，如多线程共享对象时，没有使用同机制确保共享对象的可见性，其他线程可能得到未创建完成/不一致/失效的变量状态。
    * Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证(即使对象的引用对其他线程可见但并不意味着对象状态对使用该对象的线程一定可见，需要使用同步确保对象状态的一致性)，为维持初始化安全性的保证，需满足：状态不可修改/所有域均为final/正确的构造
    * 可变对象必须通过安全的方式来发布，通常在发布和使用该对象的线程时使用同步。
    * 要安全的发布对象，需保证对象的引用和状态必须同时对其他线程可见，一个正确构造的对象可通过以下方式安全发布:
        * 在静态初始化函数中初始化一个对象的引用
        * 将对象的引用保存在volatile类型的域或者AtomicReference对象中。
        * 将对象的引用保存到正确构造的对象的final域中
        * 将对象的引用保存到一个由锁保护的域中(如线程安全容器Vector/synchronizedList)
    * 通常使用静态初始化器发布静态构造对象，静态初始化器由JVM在类的初始化阶段执行，在JVM内部存在着同步机制，因此这种方式初始化的对象可以安全发布。
    * 不可变对象可以安全发布。如果一个对象技术上是可变的，但保证其状态发布后状态不会再改变，这种对象称为事实不可变对象。(对于可变对象，不仅发布时需要同步，每次访问时同样需要同步来保证后续操作的可见性)
> 线程安全库中的容器类提供以下安全发布保证:1.将一个键或值放入，HashTable/synchronizedMap或ConcurrentMap中，可以安全的将它发布给从这些容器中访问它的线程。2.将某个元素放入Vector,CopyOnWriteArrayList,CopyOnWriteArraySet，synchronizedList，synchronizedSet中。可以安全的将它发布给从这些容器访问它的线程。3.将元素放入BlockingQueue/ConcurrentLinkQueue中可以将对象安全的发布到任何从这些队列(类库中的其他数据传递机制,如Future/Exchanage,同样能实现安全发布)
* 在并发程序中使用和共享对象时，需要使用一些策略:
    * 线程封闭:只能由一个线程拥有，该对象对象封闭在线程中，且只能由这个线程修改。
    * 只读共享:共享的只读对象可以由多个线程并发访问(不要额外的同步机制)，但不能修改。包括不可变对象和事实不可变对象。
    * 线程安全共享:线程安全对象在其内部实现同步，因此多个线程可通过对象的公有接口进行访问，而不需要其他同步。
    * 保护对象:被保护的对象只能通过持有特定的锁来访问。包括封装在其他线程安全对象中对象，以及已发布的由某个锁保护的对象。

## 对象的组合:
* 将现有线程安全组件组合为更大规模的组件或程序。
* 设计线程安全的类通常包含以下要素:
    * 1.找出构成对象的所有变量（区别基本类型／引用类型，对于引用类型对象状态同样包含引用对象的域）；
    * ２.找出约束状态变量的不变性条件；
    * ３．建立对象状态的并发访问状态管理；
    * 收集同步需求:对象与变量的所有取值称为其状态空间，许多类中都定义了一些变量性条件限制状态空间的大小，此外有些包含后验条件判断状态迁移是否有效(如：当下一个状态需要依赖当前状态时，迁移操作必须为复合操作，当不变性条件涉及多个变量时，这些相关变量必须在原子操作中读取／操作)   
    * 依赖状态的操作:类的不变性条件和后验条件约束了在对象上哪些状态转换是有效的。某些对象上包含基于状态的先验条件(如从队列移除一个元素前队列必须非空)，如果在某个操作中有基于状态的先验条件，这个操作称为依赖状态的操作，
        * 对于依赖状态的操作，先并发程序中必须要对应先验条件变为真才可以执行此类操作，可以借助类库中的类实现依赖状态的行为(如阻塞队列BlockQueue/信号量Semaphore等)；
    * 状态所有权：在考虑对象的状态包含的变量时，只需考虑对象拥有的数据，即所有权；(Java的垃圾回收器降低了所有权处理的开销，在C++中把一个对象传递给一个方法时，需考虑该操作是否传递对象的所有权，长期or短期)
        * 所有权与封装相关联，对象封装其拥有的状态，即对封装的状态拥有所有权。同时所有权意味着控制权(状态变量所有者决定采用何种加锁协议维持变量状态的完整性)，所有权分为独享or共享(状态变量被发布)，容器类通常表现出一种所有权分离的形式。 
* 实例封闭:　将一个对象封装在另一个对象中(如私有域／局部变量／或封闭在线程内)，从而将另一个对象的访问限制在该对象的方法上，访问可控，通过封闭机制与合适的加锁机制结合，可以确保以线程安全的方式来使用非线程安全对象
    * 实例封闭使得锁策略的选择更加灵活，同时使得不同的状态变量可以由不同的锁来保护
    * Java平台类库存在很多线程封闭实例，如包装器工厂方法(如Collections.synchronizedList等类似方法)使得一些容器等非线程安全的类可以在多线程安全环境下安全使用。(通过装饰器模式将容器类封装在一个同步的包装器对象中，包装器可将接口中的每个方法实现为同步方法，将调用请求转发给底层的容器对象，只要包装器对象拥有底层容器的唯一引用便可实现线程安全)
    * java监视器模式:遵循Java监视器模式的对象会把对象的所有可变状态都封装起来并由对象内置的锁来保护，是一种编程约定，如Vector,HashTable等很多类都使用了该模式(可在对象内部，利用私有锁保护对象状态，不同于对象的内置锁，对象可以将私有锁封装起来，客户代码只有通过提供的公有方法访问锁，以便参与到它的同步策略)
        * Java监视器模式，适合从头开始构建一个类，或将多个非线程安全的类组合为一个类时保证线程安全。
* 线程安全性的委托:通过将多个线程安全的类组合而成的类未必线程安全。
    * 可以将对象的状态委托给内部一个线程安全的对象来管理，从而实现线程安全。此外可以将线程安全性委托给多个状态变量，但需要这些变量彼此独立(独立的状态变量,即组合而成的类不会在其包含的多个状态变量上增加不变性条件)
    * 多状态委托涉及的多个变量存在不变性约束条件时，对于单个变量的修改可能破坏变量间的约束条件，从而组合得到的类为非线程安全。此时需要必要的加锁机制来维护变量间的不变性条件，将涉及多个变量状态的复合操作限制为原子操作(除非整个符合操作都可以委托给某个线程安全的状态变量)
    * 应根据委托的底层变量上施加的不变性条件，决定状态的发布(对于本身线程安全，且没有不变性条件约束，不存在任务无效状态转换，则可以安全发布)
* 在现有的线程安全类中添加功能:在开发中我们通常选择重用类库中一些现有的基础功能类，但有时可能现有的类不能满足我们全部的功能需求，此时需要我们在不破坏原来类的线程安全性的情况下，增加一些新的功能操作，可以选择扩展子类实现(也可以修改源代码实现)。
    * 在扩展类的功能时，应保证扩展的同步与原有类的同步相配合(原有类的同步策略的改变可能破坏扩展类的线程安全，如锁的不一致)，客户端加锁(类组合)与扩展类加锁(类继承)均将派生类的行为与基类的实现耦合在一起，可能会破坏同步策略的封装性；
    * 组合(类组合+类继承)；通过自身的内置锁增加一层额外的加锁，并不关心底层的基类是否线程安全。
* 在工程设计阶段应注意将同步策略文档化，文档中注意说明需要了解的线程安全性保证，同步策略，如volatile/加锁，哪些锁保护哪些变量，哪些变量可变或封闭在线程中，哪操作必须为原子操作等。
> 同步策略定义了如何在不违背对象不变性条件或后验条件的情况下对其状态访问操作进行协同，规定了如何将不变性／线程封闭／加锁机制等结合以维护线程安全性，规定了哪些变量由哪些锁保护 


## 基础构建模块
* 将线程安全性委托给一些现有的线程安全类是创建线程安全类的一个有效的策略,Java平台类库包含丰富的并发基础的模块，如线程安全的容器类以及各种用于协调多个相互协作线程控制流的同步工具类。
### 同步容器类:
* 包括Vector和Hashtable(以及其他功能相似的类),这些同步的封装器由Collection.synchronizedXXX更工厂方法创建，实现线程安全的方式是:将对象的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态.
* 在某些情况下，可能需要额外的客户端加锁来保护涉及线程安全的复合操作(如迭代/跳转/条件运算等)
* 迭代器与ConcurrentModificationException: 对于同步容器类的迭代器，表现出及时失败的行为，在进行迭代时当发现容器被修改，会抛出一个ConcurrentModificationException异常，采用的实现方式是：将计数器的变化与容器关联起来，如果在迭代期间计数器被修改，则hasNext或next将抛出该异常。为避免该异常的出现，可以在迭代过程中持有容器的锁或“克隆"容器，并在副本上进行迭代(副本被封闭在线程内)；
* 隐藏迭代器: 某些情况下可能会隐式的执行容器的迭代操作(如在抵用容器的toString()方法时会迭代容器，对其中的每个元素调用toString(),此外当容器作为另一个容器的元素或键值时，容器的hashCode()/equal()也会间接执行迭代操作;还有containsALl(),removeAll(),retainAll()等方法以及把容器作为参数的构造函数)
> 然而为了降低并发修改操作的检测代码带来的程序性能的影响，计数器的检检查并没有同步，因此迭代器可能得到失效的计数值，

### 并发容器:
* 同步容器将所有对线程的访问都并行化，以实现线程安全，然而这种策略会降低程序的并发性，当多个线程竞争容器锁时，吞吐量下降。
*　Java5.0提供多种并发容器类改进同步容器性能,并发容器针对多个线程并发访问容器设计，如用CconcurrentHashMap代替基于散列的Map,在遍历操作为主要操作的情况下用CopyOnWriteArrayList代替同步List
* Java5.0增加了两种新的容器类型:Queue和BlockingQueue：
    * Queue:用来临时保存一组等待处理的数据，Queue上的操作不会阻塞，如容器为空将返回空值,底层通过LinkedList实现,包括一下几种实现：
        * ConcurrnetLinkedQueue：为传统的先进先从队列
        * Priority: 为一个非并发的优先队列
    * BlockingQueue: 扩展可Queue,增加了可阻塞的插入和获取等操作，如果队列为空获取元素的操作将一直阻塞，直到队列中出现一个可用元素，对于有界队列已满，则插入元素的操作将一直阻塞，直到队列出现可用空间。使用于"生产者-消费者"模式
* Java6引入了ConcurrentSkipListMap和ConcurrentSkipListSet分别替代同步的SortedMap和SortedSet的并发实现(如用synchronizedMap包装的TreeMap和TreeSet)
#### ConcurrnetHashMap:
* 同步容器类在执行每个操作期间都持有一个锁，对于HashMap等一些基于散列的容器,在遍历等一些操作时可能消耗太多的时间(如在遍历查找中,需在很多元素上调用equal,若hashcode分布均，还会涉及在大量线性链表的遍历)，此时其他线程不能访问该容器
* 同HashMap相似，ConcurrnetHashMap也是一个基于散列的Map,但它使用可不同加锁策略来提高容器的并发性和伸缩性。ConcurrnetHashMap使用一种称为分段锁的更细粒度的加锁机制来实现更大程度上的共享，任意数量的读取线程可并发访问Map，一定数量的写入线程可并发修改Map,且读/写线程可并发访问。实现在并发环境下更高的吞吐量,在单线程环境下有很小的性能损失。
* ConcurrnetHashMap同其他一些并发容器增强了同步容器类，它们提供的迭代器不会抛出ConcurrentModificationException,因此在迭代时不需要加锁。ConcurrnethashMap返回的迭代以(但不保证)在迭代器被构造后将修改操作范颖给容器。
＊ 对于一些需要在整个Map上进行计算发方法，如size()/isEmpty()/get()/put()/containsKey()/remove()，等语义减弱，可能返回一个失效值，从而换取对其他更重要操作的优化
> 相比HashMap和synchronziedMap,ConcurrentHashMap有着更多的优势和更少的劣势，除非当应用程序需要加锁Map已进行独占访问，一般使用ConcurrnetHashMap代替同步Map提高程序的可伸缩性。
* 额外的原子Map操作:因为ConcurrentHashMap不能被加锁来执行独占访问，因此不能使用客户端加锁来实现新的原子操作，但是对于一些常见的复合操作,如“若没有则添加”/“若相等则移除”/“若相等则替换”等,都已经实现为原子操作并在ConcurrentHashMap的接口中声明

#### CopyOnWriteArrayList:
* CopyOnWriteArrayList代替同步的List,提供更好的并发性能。且在迭代期间不需要进行加锁和复制(类似的CopyOnWriteSet代替同步的Set)
* Copy-on-Write写入时复制: 只要正确发布一个事实不可变对象,那么在访问该对象时就不再需要进一步的同步。每次修改时，都会创建并重新发布一个新的副本，从而实现可变性。同时，写入时复制容器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置,因为不可修改,所以对其进行同步时只需确保数组内容。因此多个线程可以同时对这个容器迭代而不会彼此干扰或者与写修改的线程干扰，且不会跑出ConcurrentModificationExceptiin异常,且返回的元素与迭代器创建时的元素完全一致，不必考虑之后修改操作带来的影响。
* 每当修改时复制，特别对于规模较大的容器，会带来一定的性能开销，仅当迭代操作远大于修改操作时，才考虑使用写入时复制容器。如适用于事件通知系统(事件接收远大于事件的注册和注销)

### 阻塞队列和生产者-消费者模式:
* 阻塞队列提供了可阻塞的put和take方法，以及定时的offer和pull方法，队列可有界也可无界;
* 生产者-消费者能够模式降低了生产者类和消费者类之间的耦合度和代码依赖性(可将生产数据的过程与使用数据的过程解耦)，通常生产者与消费者的角色时相对的.生产者与消费者可并发执行。
* 阻塞队列简化的生产-消费模式的实现，在实现时应注意平衡两者的效率带来的影响；
* BlockingQueue有多种实现:
    * LinkedBlockQueue/ArrayBlockQueue(分别与LinkList/ArrayList类似)为先进先出队列,相比同步的List具有更好的并发性；
    * PriorityQueue为按优先级排序的队列，可以按照某种顺序操作元素，既可以根据元素的自然顺序来比较元素(如果它们实现了Comparable方法)，也可以使用Compparator来比较。
    * SynchronousQueue不会为队列中元素维护空间(不是一个真正的队列)，它维护一组等待着把元素加入或移出队列的线程(相当与不经过中间缓存，生产者直接将数据交给消费者)，降低了数据在双方间转移的延迟，其put和take会一直阻塞知道另一个线程已经准备好交付过程。仅当有较多的消费者，且总有一个消费者准备好获取交付的工作时才适用.

* 串行线程封闭:在java.util.concurrent中实现的各种阻塞队列都包含了足够的内部同步机制,从而可以安全的将对象从生产者发布到消费者线程。对于可变线程，生产-消费模型与阻塞队列一起促进了串行线程封闭，从将对象所有权从生产者交付给消费者。线程封闭保证只有一个线程拥有对象，对象封闭在所有者内部，可通过发布转移对象的所有权
* 双端队列与工作密取:java6增加了两种容器类型Deque和BlockingDeque,分别对Queue和BlockQueue进行了扩展:
    * Deque/BlockingDeque为双端队列，具实现如ArrayDeque/LinkedBlockingDeque,实现了在队头队尾的高校插入和移除
    * 双端队列适合与工作密取模式，不同取生产-消费模型中的每个消费者有一个共享的工作队列，工作密取模式中，每个消费者都有各自的双端队列。如果一个消费者完成了自己队列中的全部工作，则它可以从其他消费者双端队列的末尾秘密的获取工作；
    * 相比传统的生产-消费模型，工作密取模式具有更高的伸缩性，降低了个消费者在获取队列元素时的竞争。使用与既是生产者又是消费者的问题(执行某个工作可能导致更多的工作，如爬虫获取网页，许多搜索图算法，垃圾回收的堆标记等)，可实现高校并行。

### 阻塞方法与中断方法：
* 线程可能由于一些其他原因阻塞或暂停执行，当线程阻塞时，通常会被挂起，并处于某种阻塞状态(BLOCKED,WAITING,TIMED_WAITING),必须等待某个不受它控制的事件发生才能被唤醒继续执行。
* BlockingDeque的put和take操作会抛出受检查异常InterruptedException,类似类库的其他一些方法(如Thread.sleep)。抛出InterruptedException表示该方法是一个阻塞方法，如果这个方法被中断，它将努力提前结束阻塞状态
* Thread提供了interrupt方法，用于中断线程或查询线程是否已经被终端。每个线程都有一个布尔类型的属性，表示线程终端状态，当中断线程时设置。
* 中断是一种协作机制，一个线程可以要求另一个线程在某个可以暂停的地方停止正在执行的操作，前提是另一线程愿意停下来而不能强制；