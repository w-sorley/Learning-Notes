---
titile: 多核应用编程实战学习记录
tags: [多线程,并发,多核,实战]
date: 2018-04-07
---

# 多核应用编程实战学习记录

## 使用POSIX线程

* 简介: POSIX标准规定了可移植UNIX应用程序的编码标准,多核UNIX和类UNIX操作系统都支持POSIX标准的关键功能,因此按照此标准编制的应用程序将可在Linux,FreeBSD等以UNIX为内核的OS,以及基于类UNIX内接的Mac OS操作系统之间移植;
> Windows并未直接实现POSIX标准,但有一些解决方案能让用POSIX接口编写的程序在Windows平台运行


### 创建线程
* 创建新线程
    * int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, (void*)(*start_rtn)(void*),void *arg);
        * 参数:
            * tidp:返回线程句柄;
            * attr:线程属性结构的指针;
            * start_rtn:新线程执行的例程地址;
            * arg:作为参数传入新线程的值或指针
        * 返回值:成功返回0;失败返回错误状态码
        * 编译链接参数:\-lpthread
* 线程终止
    * 子线程在完成分配给它们的例程时终止(?为什么实际pthread_code有时产生两个输出)
    * 主线程可利用pthread_jion()使用子线程运行例程的返回值
        * 
    * 线程终止的另外一个方法是调用pthread_exit():
        * 参数:0或void指针,传递返回值,主线程可通过pthread_join()获取
        * 子线程无需显式调用pthread_exit(),线程退出时会隐式调用;
    * 除了分离线程,否则线程使用的资源要等到另一个线程以该退出线程的句柄为传入参数调用pthread_jion()才会释放
* 用子线程接收和传递数据
    * 要将数据传入子线程,首先应将数据转换为一个指向void的指针,然后将之作为参数传递给pthread_create(),注意不要传入指向不断变化的变量的指针或者指向栈信息的指针;

```
#include<pthread.h>
#include<stdio.h>

//新线程执行的例程
void* thread_code(void* param)
{
    printf("In thread code \n");
    printf("children tread receive value:%d",(int)param);  \\ +++   ?*(int*)param
    return (void*)1; // ++
}

int main()
{
    pthread_t thread;  //指向新线程的句柄
   /* pthread_create(&thread, 0, &thread_code, 0);  \\attr=0使用默认属性  */
    pthread_create(&thread, 0, &thread_code, (void*)12);
    printf("In main thread! \n");
    pthread_jion(thread,0);  // +
    pthread_join(thread, ret);    // ++
    printf("return value%d \n",*(int*)ret);   /++
}
```
#### 分离线程
* 分离线程:无需等待另外一个线程调用pthread\_jion()其所占资源就可回收(对分离线程调用pthread\_jion()会出错),有两种创建方法
    * 1.在线程属性结构中设置相应的属性
    * 2.对现有线程调用pthread_detach()
* 分离线程的句柄在线程退出时被回收,句柄的任何缓存版本不再指向原线程
```
#include<pthread.h>
#include<stdio.h>

 void* child_routine(void* param)
{
    int id = (int)param;
    printf("Detach thread %i \n", id);
    pthread_detach(pthread_self());
}
int main()
{
    pthread_t thread[100];
    for(int i=0;i<10;i++)
    {   
        pthread_create(&thread[i], 0, child_routine, (void*)i);
    }   
}
```
#### 设置pthread的属性
* 线程属性在创建时设置,有些在之后可以修改(如线程分离状态),有些则不能修改:
    * 创建一个线程属性结构:pthread\_aar\_t
    * 初始化属性结构体pthread\_attr\_init(&pthread_t)
    * 使用对应的函数设置相关属性,如:
        * 设置为分离状态 pthread\_attr\_setdetachstate(&attr, PTHREAD\_CREATE\_DETACHED);
        * 获取线程的栈大小属性: size\_t stacksize;  pthread\_attr\_getstacksize(&attr,&stacksize);
            * 控制栈大小的另外一个命令是ulimit -s \<stacksize\>
    * 将此结构作为参数传递给创建函数pthread_create()
    * 使用后可以随时调用pthread\_attr\_destroy()销毁
> 为了让堆(malloc从堆中获得内存)和栈增长,堆通常放置在应用程序之后,位于可寻址内存的低端,而栈通常放在内存的上端 <\br>
  每个线程会收到分配给其栈的一个固定大小的连续内存块,因为可用地址空间有限,所以栈空间所用内存取自可用于堆的内存;提供给一个线程的绝对最小可接受内存存储于变量PTHREAD\_STACK\_MIN中

### 编译多线程代码
* 编译多线程代码可能出现问题的两个地方是头文件和库文件
* 当以gcc进行生产时,使用编译器标志\-pthread,不仅会传递标志\-D_REENTRANT(需要定义该标志),还会与POSIX线程库链接;
### 进程终止
* 当主线程结束后,所有子线程都将终止,其资源被释放
* 主线程可以调用pthread\_exit(),从而保证主线程等待所有线程结束再退出(即使子线程已分离也是如此)

### 线程之间共享数据cd
