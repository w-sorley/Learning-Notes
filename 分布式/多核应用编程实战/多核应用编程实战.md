---
titile: 多核应用编程实战学习记录
tags: [多线程,并发,多核,实战]
date: 2018-04-07
---

# 多核应用编程实战学习记录

## 使用POSIX线程

* 简介: POSIX标准规定了可移植UNIX应用程序的编码标准,多核UNIX和类UNIX操作系统都支持POSIX标准的关键功能,因此按照此标准编制的应用程序将可在Linux,FreeBSD等以UNIX为内核的OS,以及基于类UNIX内接的Mac OS操作系统之间移植;
> Windows并未直接实现POSIX标准,但有一些解决方案能让用POSIX接口编写的程序在Windows平台运行


### 创建线程
* 创建新线程
    * int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, (void*)(*start_rtn)(void*),void *arg);
        * 参数:
            * tidp:返回线程句柄;
            * attr:线程属性结构的指针;
            * start_rtn:新线程执行的例程地址;
            * arg:作为参数传入新线程的值或指针
        * 返回值:成功返回0;失败返回错误状态码
        * 编译链接参数:\-lpthread
* 线程终止
    * 子线程在完成分配给它们的例程时终止(?为什么实际pthread_code有时产生两个输出)
    * 主线程可利用pthread_jion()使用子线程运行例程的返回值
        * 
    * 线程终止的另外一个方法是调用pthread_exit():
        * 参数:0或void指针,传递返回值,主线程可通过pthread_join()获取
        * 子线程无需显式调用pthread_exit(),线程退出时会隐式调用;
    * 除了分离线程,否则线程使用的资源要等到另一个线程以该退出线程的句柄为传入参数调用pthread_jion()才会释放
* 用子线程接收和传递数据
    * 要将数据传入子线程,首先应将数据转换为一个指向void的指针,然后将之作为参数传递给pthread_create(),注意不要传入指向不断变化的变量的指针或者指向栈信息的指针;

```
#include<pthread.h>
#include<stdio.h>

//新线程执行的例程
void* thread_code(void* param)
{
    printf("In thread code \n");
    printf("children tread receive value:%d",(int)param);  \\ +++   ?*(int*)param
    return (void*)1; // ++
}

int main()
{
    pthread_t thread;  //指向新线程的句柄
   /* pthread_create(&thread, 0, &thread_code, 0);  \\attr=0使用默认属性  */
    pthread_create(&thread, 0, &thread_code, (void*)12);
    printf("In main thread! \n");
    pthread_jion(thread,0);  // +
    pthread_join(thread, ret);    // ++
    printf("return value%d \n",*(int*)ret);   /++
}
```
#### 分离线程
* 分离线程:无需等待另外一个线程调用pthread\_jion()其所占资源就可回收(对分离线程调用pthread\_jion()会出错),有两种创建方法
    * 1.在线程属性结构中设置相应的属性
    * 2.对现有线程调用pthread_detach()
* 分离线程的句柄在线程退出时被回收,句柄的任何缓存版本不再指向原线程
```
#include<pthread.h>
#include<stdio.h>

 void* child_routine(void* param)
{
    int id = (int)param;
    printf("Detach thread %i \n", id);
    pthread_detach(pthread_self());
}
int main()
{
    pthread_t thread[100];
    for(int i=0;i<10;i++)
    {   
        pthread_create(&thread[i], 0, child_routine, (void*)i);
    }   
}
```
#### 设置pthread的属性
* 线程属性在创建时设置,有些在之后可以修改(如线程分离状态),有些则不能修改:
    * 创建一个线程属性结构:pthread\_aar\_t
    * 初始化属性结构体pthread\_attr\_init(&pthread_t)
    * 使用对应的函数设置相关属性,如:
        * 设置为分离状态 pthread\_attr\_setdetachstate(&attr, PTHREAD\_CREATE\_DETACHED);
        * 获取线程的栈大小属性: size\_t stacksize;  pthread\_attr\_getstacksize(&attr,&stacksize);
            * 控制栈大小的另外一个命令是ulimit -s \<stacksize\>
    * 将此结构作为参数传递给创建函数pthread_create()
    * 使用后可以随时调用pthread\_attr\_destroy()销毁
> 为了让堆(malloc从堆中获得内存)和栈增长,堆通常放置在应用程序之后,位于可寻址内存的低端,而栈通常放在内存的上端 <\br>
  每个线程会收到分配给其栈的一个固定大小的连续内存块,因为可用地址空间有限,所以栈空间所用内存取自可用于堆的内存;提供给一个线程的绝对最小可接受内存存储于变量PTHREAD\_STACK\_MIN中

### 编译多线程代码
* 编译多线程代码可能出现问题的两个地方是头文件和库文件
* 当以gcc进行生产时,使用编译器标志\-pthread,不仅会传递标志\-D_REENTRANT(需要定义该标志),还会与POSIX线程库链接;
### 进程终止
* 当主线程结束后,所有子线程都将终止,其资源被释放
* 主线程可以调用pthread\_exit(),从而保证主线程等待所有线程结束再退出(即使子线程已分离也是如此)

### 线程之间共享数据
#### 使用互斥锁保护访问
* 互斥锁是POSIX标准支持的一种机制,一次只有一个线程能够获得互斥量;
    * pthread\_mutex\_t 创建互斥量
    * pthread\_mutex\_init(&mutex_t,0)初始化为适当的状态,或将值PTHREAD\_MUTEX\_INITALIZER赋予静态定义的互斥量
    * 可以调用pthread\_mutex\_destroy(&mutex_t)释放其占用资源
    * 线程可以通过调用pthread\_mutex\_lock(&mutex_t)锁定互斥量,使用完毕后调用pthread\_mutex\_unlock()释放互斥量(在此期间其他调用pthread\_mutex\_lock()获得对应互斥量的线程将会阻塞等待)
    * pthread\_mutex\_trylock()调用将尝试获取互斥量,如果成功,该函数返回0并成为互斥量的所有者;否则立即返回一个非零值表示获取失败;
#### 互斥锁属性
* 默认情况下,互斥量为进程私有.要创建一个能在进程间共享的互斥量,必须为pthread\_mutex\_init()设置属性,其他属性如:
    * 互斥量的类型,可以是普通互斥量,也可以是检测错误
    * 当另一个线程等待该互斥量时遵循的协议,优先级等
    * 互斥量的优先级上限
```
#include<pthread.h>
#include<stdio.h>

pthread_mutex_t mutex;
volatile int counter = 0;

void * count(void* param)
{
    for(int i=0; i<100;i++)
    {   
        pthread_mutex_lock(&mutex);
        counter++;
        printf("Count = %i \n",counter);
        pthread_mutex_unlock(&mutex);
    }   
}

int main()
{
    pthread_t thread1, thread2;
    pthread_mutex_init(&mutex,0);
    //+  如:设置互斥量的进程分离属性:
 //   pthread_mutexattr_t attributes;   // +
 // pthread_mutexattr_setpshared(&ttributes,PTHREAD_PROCESS_SHARED) //+
    pthread_create(&thread1, 0, count, 0); 
    pthread_create(&thread2, 0, count, 0); 
    pthread_join(thread1,0);
    pthread_join(thread2,0);
    pthread_mutex_destroy(&mutex);
    return 0;
}
```
#### 使用自旋锁
* 自旋锁和互斥锁的关键区别在于自旋锁将在一个紧凑的循环中持续旋转并消耗处理器资源,直到最终获取锁.此外,自适应自旋锁则在线程陷入休眠之前稍作自旋等待锁释放
    * pthread\_spinlock\_t :声明一个自旋锁结构;
    * 调用pthread\_spin\_init()初始化自旋锁,或使用传递参数PTHREAD\_PROCESS\_PRIVATE或PTHREAD\_PROCESS\_SHARED,指定该锁为线程私有或者线程共享
    * 使用pthread\_spin\_lock()将旋转直到获得该锁;
    * 使用pthread\_spin\_unlock()释放该锁
    * 最后可调用pthread\_spin\_destroy()将释放该锁占用的任何资源
    * pthread_spin_trylock()调用将尝试获得锁,无论是否成功获得都会立即返回

```
#include<pthread.h>
#include<stdio.h>

pthread_spinlock_t lock;
int count = 0;
void lockandunlock()
{
    int i = 1000;
    while(i>0)
    {   
    //    pthread_spin_lock(&lock);
    //    i--;
    //    pthread_spin_unlock(&lock);
         if(pthread_spin_trylock(&lock))
         {   
             i--;
             pthread_spin_unlock(&lock);
    
         }else{
             count++;
         }
    }   
    printf("Failed tries = %i \n",count);
}
 int main()
{
  //  pthread_spin_init(&lock, PTHREAD_PROCESS_PRIVATE);
    pthread_spin_init(&lock, PTHREAD_PROCESS_SHARED);  // +
    lockandunlock();
    pthread_spin_destroy(&lock);
}
```
#### 读写锁
* 读写锁允许多个线程同时读一个资源,但一次只有一个线程可以更新该资源:
    * pthread\_rwlock\_t声明一个读写锁
    * 可以调用pthread\_rwlock\_init()初始化或通过利用PTHREAD\_RWLOC\_INITALIZER赋值进行静态初始化
    * pthread\_rwlock\_rdlock()和pthread\_rwlock\_rdunlock()读锁定和读解锁
    * pthread\_rwlock\_wrlock()和pthrea\_rwlock\_wrunlock()写锁定和写解锁
    * 尝试获得读取锁的调用pthread\_rwlock\_tryrwlock();尝试获得写入锁的调用是pthread\_rwlock\_trywrlock()
* 要创建在进程间共享的读写锁,必须创建和使用一组属性:
    * pthread\_rwlockattr\_t 声明属性结构
    * 调用pthread\_rwlockattr\_init()初始化属性
    * 调用pthread\_rwlock\_setpshared()将共享属性设置为所需值(PTHREAD\_PROCESS\_SHARED)
    * 不再使用时,可以调用pthread\_rwlockattr\_destroy()销毁属性,释放其占用的资源
* 可以在获取锁时使用超时,如
    * pthread\_rwlock\_timedrdlock()和pthread\_rwlock\_timedwelock(),在获得锁时返回0,在指定的绝对时间内未获得锁则返回错误码
    * pthread\_rwlock\_timedrdlock\_np()和pthread\_rwlock\_timedwelock\_np(),在获得锁时返回0,在指定的相对时间内未获得锁则返回错误码
    * timespec 结构用来作为参数指定定时信息
    * 对于绝对时间,可以调用clock\_gettime()并给定当前时间来初始化此结构,如
    ```
    struct timespec now;
    clock\_gettime(CLOCK\_REALTIME,&now);
    now.tv\_sec += \{int\}
    ```
#### 屏障
* 在某些情况下,程序需要等待一组线程全部完成其工作才能有所进展,这种情况称为屏障:
    * 调用pthread\_barrier\_init()创建屏障,通常需要以下参数:
        * 指向将要被初始化屏障的指针
        * 一个可选的属性结构,决定屏障为进程私有还是在进程之间共享
        * 释放任何线程前需要达到的屏障的线程数
    * 每个线程在达到屏障时都调用pthread\_barrier\_wait(),此调用将在达到屏障的线程达到一定数量后返回
```
#include<pthread.h>
#include<stdio.h>

pthread_barrier_t barrier;

void* work(void* param)
{
    int id =(int)param;
    printf("Thread arrived %i \n",id);
    pthread_barrier_wait(&barrier);
    printf("Thread departrd %i \n",id);
}
int main()
{
    pthread_t threads[10];
    pthread_barrier_init(&barrier, 0, 10);
    for(int i=0;i<10;i++)
    {   
        pthread_create(&threads[i], 0, work, (void*)i);

    }   
    for(int i=0;i<10;i++)
    {   
        pthread_join(threads[i],0);
    }   
    pthread_barrier_destroy(&barrier);
}
```
#### 信号量
* 信号量是一个计数和信号机制,其用途之一就是允许线程访问指定数量的数据项.信号分为两种:
     * 未命名信号量:
        * sem_t 声明一个指向信号量的指针
        * 调用sem\_init()初始化未命名信号量,使用完成后可调用sem\_destroy()摧毁,释放其占用的资源
    * 命名信号量:
        * 命名信号量需要打开(而不是初始化),此过程类似于打开一个文件,调用sem_open()返回一个指向信号量的指针,包括一下参数:
            * 信号量的名称(符合OS文件命令规则)
            * 一组标志(若不传则默认信号量必须存在,且具有适当权限)
                * O\_CREATE;信号量将被创建,无论信号量是否存在,都将返回现有版本的指针
                * O\_EXCL:可与O\_CREATE一起使用,表示仅当信号量尚未存在时才会成功返回信号量 
        * 调用sem\_close()关闭命名信号量.此调用将关闭与信号量的连接,但信号量仍存在与计算机上
        * 调用sem_unlink()并指定信号量的名字将释放其所占用的资源,但仅当所有打开该信号量的进程都关闭与其的连接时才生效;
* 操作信号量
    * sem_wait()将尝试减小信号量,如果其值为0则阻塞等待(直到信号量变为非零返回),然后执行递减操作
    * 调用sem_trywait()则无论是成功递减信号量还是信号量已经为0都将立即返回
    * sem_post()将递增信号量
    * sem_getvalue()会将信号量的当前值写入一个整数变量 
* 信号量可作为互斥量使用,当做线程之间的信号.如,信号量可用来表示一个任务已完成,或用来确保两个任务将按照预定的顺序执行
    * 信号量初始值为0,在第一个线程的结束执行递增操作,在第二个线程的开始执行递减操作
*信号量也可以用来控制对有限数量元素的访问，如，可利用信号量设计生产者-消费者系统:
    * 用两个信号量,分别表示当前可用资源数,和缓冲区的可用位置
```
// 使用未命名信号量
#include<pthread.h>
#include<stdio.h>
#include<semaphore.h>

int main()
{
    sem_t semaphore;
    int counter =0; 

    sem_init(&semaphore, 0, 1); 
    sem_wait(&semaphore);
    counter++;
    sem_post(&semaphore);
    sem_destroy(&semaphore);
}
```
#### 条件变量
* 条件变量使线程能够交流状态变化.使用条件变量需要一个互斥量和一个条件变量,以及线程要检查的其他状态
    * pthread\_cond\_t声明一个指向条件变量的指针
    * 调用pthread\_cond\_init()初始化条件变量,参数为条件变量地址和属性
    * 调用pthread\_cond\_destroy()销毁条件变量
* 条件变量默认我进程私有,属性可用于创建可在进程间共享的条件变量:
    * pthread\_condattr\_t CVA
    * pthread\_condattr\_setpshared(&CVA, PTHREAD\_PROCESS\_SHARED)

* 如果没有等待条件变量的线程,pthread\_cond\_signal()调用无效;函数pthread\_cond\_broadcast()唤醒所有等待条件变量的线程
* 当使用广播唤醒机制时,可能出现假唤醒的情况;同时当为等待条件变量的线程编写代码时要注意避免唤醒丢失(信号到来时,等待线程还没有准备好接收信号)
* pthread\_cond\_timedwait()其参数为等待超时时间,条件变量,互斥量;返回时将持有互斥锁或返回错误代码
```
//生产者-消费者
#include<pthread.h>
#include<stdio.h>

pthread_cond_t cv; 
pthread_mutex_t mutex;
int length;

int queue[200];

void* producer(void* param)
{
    for(int i=0;i<200;i++)
    {   
        pthread_mutex_lock(&mutex);
        queue[length++]=i;
      //  pthread_cond_signal(&cv);
        pthread_cond_broadcast(&cv);
        pthread_mutex_unlock(&mutex);
    }   
}
void* consumer(void* param)
{
    for(int i=0;i<200;i++){
        pthread_mutex_lock(&mutex);
        while(length == 0){ 
            pthread_cond_wait(&cv,&mutex);
        }
        int item = queue[--length];
        pthread_mutex_unlock(&mutex);
        printf("Received %i \n",item);
    }   
}

int main()
{
    pthread_t threads[2];
    pthread_cond_init(&cv, 0); 
    pthread_mutex_init(&mutex,0);

    length =0; 
    pthread_create(&threads[0], 0, producer, 0); 
    pthread_create(&threads[1], 0, consumer, 0); 
    pthread_join(threads[1],0);
    pthread_join(threads[0],0);
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cv);
}
```

### 变量和内存
:
