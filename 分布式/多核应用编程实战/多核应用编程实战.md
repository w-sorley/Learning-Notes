---
titile: 多核应用编程实战学习记录
tags: [多线程,并发,多核,实战]
date: 2018-04-07
---

# 多核应用编程实战学习记录

## 使用POSIX线程

* 简介: POSIX标准规定了可移植UNIX应用程序的编码标准,多核UNIX和类UNIX操作系统都支持POSIX标准的关键功能,因此按照此标准编制的应用程序将可在Linux,FreeBSD等以UNIX为内核的OS,以及基于类UNIX内接的Mac OS操作系统之间移植;
> Windows并未直接实现POSIX标准,但有一些解决方案能让用POSIX接口编写的程序在Windows平台运行


### 创建线程
* 创建新线程
    * int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, (void*)(*start_rtn)(void*),void *arg);
        * 参数:
            * tidp:返回线程句柄;
            * attr:线程属性结构的指针;
            * start_rtn:新线程执行的例程地址;
            * arg:作为参数传入新线程的值或指针
        * 返回值:成功返回0;失败返回错误状态码
        * 编译链接参数:\-lpthread
* 线程终止
    * 子线程在完成分配给它们的例程时终止(?为什么实际pthread_code有时产生两个输出)
    * 主线程可利用pthread_jion()使用子线程运行例程的返回值
        * 
    * 线程终止的另外一个方法是调用pthread_exit():
        * 参数:0或void指针,传递返回值,主线程可通过pthread_join()获取
        * 子线程无需显式调用pthread_exit(),线程退出时会隐式调用;
    * 除了分离线程,否则线程使用的资源要等到另一个线程以该退出线程的句柄为传入参数调用pthread_jion()才会释放
* 用子线程接收和传递数据
    * 要将数据传入子线程,首先应将数据转换为一个指向void的指针,然后将之作为参数传递给pthread_create(),注意不要传入指向不断变化的变量的指针或者指向栈信息的指针;

```
#include<pthread.h>
#include<stdio.h>

//新线程执行的例程
void* thread_code(void* param)
{
    printf("In thread code \n");
    printf("children tread receive value:%d",(int)param);  \\ +++   ?*(int*)param
    return (void*)1; // ++
}

int main()
{
    pthread_t thread;  //指向新线程的句柄
   /* pthread_create(&thread, 0, &thread_code, 0);  \\attr=0使用默认属性  */
    pthread_create(&thread, 0, &thread_code, (void*)12);
    printf("In main thread! \n");
    pthread_jion(thread,0);  // +
    pthread_join(thread, ret);    // ++
    printf("return value%d \n",*(int*)ret);   /++
}
```
